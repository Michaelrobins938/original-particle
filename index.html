```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiobook Narrator Orb</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(45deg, #000000, #0a0a0a);
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            user-select: none;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 16px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(20px);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            max-width: 340px;
            min-width: 300px;
        }
        
        .control-group {
            margin-bottom: 18px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        label {
            color: #00FFFF;
            display: block;
            margin-bottom: 10px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1.8px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        input[type="file"] {
            color: #fff;
            background: linear-gradient(135deg, #111, #1a1a1a);
            border: 2px solid #00FFFF;
            padding: 12px 16px;
            border-radius: 10px;
            width: 100%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            font-size: 13px;
        }
        
        input[type="file"]:hover {
            border-color: #FF0055;
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }
        
        input[type="file"]:focus {
            outline: none;
            border-color: #FF0055;
            box-shadow: 0 0 25px rgba(255, 0, 85, 0.5);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .button-group button:last-child {
            grid-column: 1 / -1;
        }
        
        button {
            background: linear-gradient(135deg, #00FFFF, #FF0055);
            border: none;
            color: #000;
            padding: 14px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 15px rgba(0, 255, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            font-size: 11px;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 
                0 8px 25px rgba(255, 0, 85, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            background: linear-gradient(135deg, #FF0055, #FF6600);
        }
        
        button:active:not(:disabled) {
            transform: translateY(-1px);
        }
        
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            background: #333;
            box-shadow: none;
        }
        
        #audioInfo {
            color: #00FF66;
            font-size: 13px;
            padding: 16px;
            background: rgba(0, 255, 102, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 102, 0.3);
            display: none;
            backdrop-filter: blur(10px);
        }
        
        #audioTitle {
            font-weight: 700;
            margin-bottom: 8px;
            word-break: break-word;
            text-shadow: 0 0 8px rgba(0, 255, 102, 0.5);
        }
        
        #audioTime {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            opacity: 0.9;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-block;
        }
        
        #info {
            color: #888;
            font-size: 11px;
            line-height: 1.7;
            background: rgba(0, 0, 0, 0.2);
            padding: 16px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #info strong {
            color: #00FFFF;
        }
        
        kbd {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            color: #00FFFF;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00FFFF;
            font-size: 20px;
            z-index: 200;
            display: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #00FFFF;
            backdrop-filter: blur(20px);
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 255, 255, 0.3);
            border-top: 4px solid #00FFFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .message {
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 12px;
            font-weight: 600;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .error-message {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.15);
            border: 1px solid rgba(255, 68, 68, 0.3);
            display: none;
        }
        
        .success-message {
            color: #00ff44;
            background: rgba(0, 255, 68, 0.15);
            border: 1px solid rgba(0, 255, 68, 0.3);
            display: none;
        }
        
        .drop-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 255, 0.1);
            border: 4px dashed #00FFFF;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 150;
            font-size: 28px;
            color: #00FFFF;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 800;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            backdrop-filter: blur(10px);
        }
        
        .drop-zone.active {
            display: flex;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            #controls {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                padding: 20px;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
            
            .button-group button:last-child {
                grid-column: 1;
            }
            
            .drop-zone {
                font-size: 20px;
                padding: 20px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div class="drop-zone" id="dropZone">
            üéß Drop Your Audiobook Here üéß
        </div>
        
        <div id="controls">
            <div class="control-group">
                <label for="audioFile">üìö Audiobook File</label>
                <input type="file" id="audioFile" accept="audio/*,video/*">
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="playBtn" disabled>‚ñ∂ Play</button>
                    <button id="pauseBtn" disabled>‚è∏ Pause</button>
                    <button id="exportBtn" disabled>üé¨ Export Video</button>
                </div>
            </div>
            
            <div class="control-group">
                <div id="audioInfo">
                    <div id="audioTitle">No file loaded</div>
                    <div id="audioTime">00:00 / 00:00</div>
                </div>
            </div>
            
            <div class="message error-message" id="errorMessage"></div>
            <div class="message success-message" id="successMessage"></div>
            
            <div class="control-group">
                <div id="info">
                    üéß <strong>Load your audiobook</strong><br>
                    üîÆ Watch the orb react to speech<br>
                    üìπ Export cinematic videos<br>
                    <br>
                    <strong>Controls:</strong><br>
                    <kbd>Space</kbd> Play/Pause<br>
                    <kbd>E</kbd> Export Video<br>
                    <br>
                    <em>Supports: MP3, WAV, MP4, M4A, OGG</em>
                </div>
            </div>
        </div>
        
        <div id="loading">
            <div class="loading-spinner"></div>
            <div>Processing audiobook...</div>
        </div>
    </div>

    <!-- Three.js from CDN with error handling -->
    <script>
        // Global error handler to catch extension conflicts
        window.addEventListener('error', function(e) {
            // Only log errors from our domain, ignore extension errors
            if (e.filename && e.filename.includes('github.io')) {
                console.error('App Error:', e.error);
            }
        });
        
        // Suppress extension-related console noise
        const originalConsoleError = console.error;
        console.error = function(...args) {
            const message = args.join(' ');
            // Filter out extension-related errors
            if (message.includes('moz-extension://') || 
                message.includes('Surfe.be') || 
                message.includes('SES ') ||
                message.includes('Components object') ||
                message.includes('lockdown-install')) {
                return; // Don't log extension errors
            }
            originalConsoleError.apply(console, args);
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" 
            onerror="document.getElementById('errorMessage').style.display='block';document.getElementById('errorMessage').textContent='Failed to load 3D graphics. Please check your internet connection.'"></script>
    <script>
        // Verify Three.js loaded
        if (typeof THREE === 'undefined') {
            document.getElementById('errorMessage').style.display = 'block';
            document.getElementById('errorMessage').textContent = 'Three.js failed to load. Please refresh the page.';
        } else {
            console.log('‚úÖ Three.js loaded successfully');
        }
    </script>
    <script src="main.js"></script>
</body>
</html>
```

### main.js (Clean Version)
```javascript
(function() {
    'use strict';
    
    // Namespace protection
    window.AudiobookNarratorOrb = class AudiobookNarratorOrb {
        constructor() {
            // Immediate Three.js check
            if (typeof THREE === 'undefined') {
                this.showError('Three.js library failed to load. Please refresh the page.');
                return;
            }

            // Initialize properties
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            
            // Audio system
            this.audioElement = null;
            this.audioContext = null;
            this.analyser = null;
            this.source = null;
            this.dataArray = null;
            
            // Visual components
            this.narratorOrb = null;
            this.starField = null;
            this.reflectionPlane = null;
            this.reflectedOrb = null;
            this.lights = {};
            
            // Audio analysis for speech
            this.amplitude = 0;
            this.smoothedAmplitude = 0;
            this.voiceFrequencies = {
                subBass: 0,     // 20-60Hz
                bass: 0,        // 60-250Hz  
                lowMid: 0,      // 250-500Hz (fundamental voice)
                mid: 0,         // 500-2kHz (vowels, clarity)
                highMid: 0,     // 2-4kHz (consonants)
                presence: 0,    // 4-6kHz (speech presence)
                brilliance: 0   // 6kHz+ (sibilance, air)
            };
            
            // Speech reactivity settings
            this.speechReactivity = {
                intensity: 3.5,
                responsiveness: 0.25,
                smoothing: 0.15
            };
            
            // Neon color palette
            this.neonColors = {
                electricBlue: new THREE.Color(0x00FFFF),
                scorchedPink: new THREE.Color(0xFF0055),
                ultravioletOrange: new THREE.Color(0xFF6600),
                toxicGreen: new THREE.Color(0x00FF66)
            };
            
            this.clock = new THREE.Clock();
            this.isPlaying = false;
            this.mediaRecorder = null;
            this.recordedChunks = [];
            this.isInitialized = false;
            
            // Initialize with error handling
            this.safeInit();
        }
        
        async safeInit() {
            try {
                await this.init();
                this.setupEventListeners();
                this.animate();
                this.isInitialized = true;
                console.log('‚úÖ Audiobook Narrator Orb initialized successfully');
                this.showSuccess('üéØ Audiobook Narrator Orb ready!');
            } catch (error) {
                console.error('Initialization error:', error);
                this.showError(`Failed to initialize: ${error.message}`);
            }
        }
        
        showError(message) {
            const errorElement = document.getElementById('errorMessage');
            if (errorElement) {
                errorElement.textContent = message;
                errorElement.style.display = 'block';
            }
            
            // Hide success message
            const successElement = document.getElementById('successMessage');
            if (successElement) {
                successElement.style.display = 'none';
            }
        }
        
        showSuccess(message) {
            const successElement = document.getElementById('successMessage');
            if (successElement) {
                successElement.textContent = message;
                successElement.style.display = 'block';
            }
            
            // Hide error message
            const errorElement = document.getElementById('errorMessage');
            if (errorElement) {
                errorElement.style.display = 'none';
            }
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (successElement && successElement.style.display === 'block') {
                    successElement.style.display = 'none';
                }
            }, 3000);
        }
        
        async init() {
            // Scene setup
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x000000);
            
            // Camera setup
            this.camera = new THREE.PerspectiveCamera(
                50, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            this.camera.position.set(0, 1, 8);
            this.camera.lookAt(0, 0, 0);
            
            // Renderer setup with fallbacks
            await this.setupRenderer();
            
            // Add to container
            const container = document.getElementById('canvas-container');
            if (container) {
                container.appendChild(this.renderer.domElement);
            } else {
                document.body.appendChild(this.renderer.domElement);
            }
            
            // Create scene elements
            this.setupLighting();
            this.createStarField();
            this.createNarratorOrb();
            this.createReflectionSystem();
        }
        
        async setupRenderer() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('webgl2') || canvas.getContext('webgl');
            
            if (!context) {
                throw new Error('WebGL not supported on this device');
            }
            
            try {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    preserveDrawingBuffer: true,
                    powerPreference: "high-performance",
                    alpha: false
                });
            } catch (error) {
                console.warn('High-performance WebGL failed, using standard:', error);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    preserveDrawingBuffer: true,
                    alpha: false
                });
            }
            
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Enhanced rendering settings
            if (this.renderer.capabilities.isWebGL2) {
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
            }
            
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Performance optimizations
            this.renderer.info.autoReset = false;
        }
        
        setupLighting() {
            // Key light (Electric Blue)
            this.lights.keyLight = new THREE.PointLight(this.neonColors.electricBlue, 2, 20);
            this.lights.keyLight.position.set(4, 4, 4);
            this.lights.keyLight.castShadow = true;
            this.lights.keyLight.shadow.mapSize.setScalar(1024);
            this.scene.add(this.lights.keyLight);
            
            // Fill light (Scorched Pink)  
            this.lights.fillLight = new THREE.PointLight(this.neonColors.scorchedPink, 1.5, 15);
            this.lights.fillLight.position.set(-3, 2, 3);
            this.scene.add(this.lights.fillLight);
            
            // Rim light (Toxic Green)
            this.lights.rimLight = new THREE.DirectionalLight(this.neonColors.toxicGreen, 1);
            this.lights.rimLight.position.set(-2, -1, -4);
            this.scene.add(this.lights.rimLight);
            
            // Ambient base
            this.lights.ambient = new THREE.AmbientLight(0x0a0a0a, 0.3);
            this.scene.add(this.lights.ambient);
        }
        
        createStarField() {
            const starCount = 1500;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                
                // Spherical distribution
                const radius = 80 + Math.random() * 120;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);
                
                // Color variety
                const colorChoice = Math.random();
                if (colorChoice < 0.4) {
                    colors[i3] = 0.0; colors[i3 + 1] = 1.0; colors[i3 + 2] = 1.0;
                } else if (colorChoice < 0.7) {
                    colors[i3] = 1.0; colors[i3 + 1] = 0.0; colors[i3 + 2] = 0.33;
                } else if (colorChoice < 0.9) {
                    colors[i3] = 0.0; colors[i3 + 1] = 1.0; colors[i3 + 2] = 0.4;
                } else {
                    colors[i3] = 1.0; colors[i3 + 1] = 0.4; colors[i3 + 2] = 0.0;
                }
                
                sizes[i] = Math.random() * 3 + 0.5;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            this.starField = new THREE.Points(geometry, material);
            this.scene.add(this.starField);
        }
        
        createNarratorOrb() {
            const geometry = new THREE.SphereGeometry(1.8, 128, 64);
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    amplitude: { value: 0 },
                    subBass: { value: 0 },
                    bass: { value: 0 },
                    lowMid: { value: 0 },
                    mid: { value: 0 },
                    highMid: { value: 0 },
                    presence: { value: 0 },
                    brilliance: { value: 0 },
                    reactivity: { value: this.speechReactivity.intensity },
                    electricBlue: { value: this.neonColors.electricBlue },
                    scorchedPink: { value: this.neonColors.scorchedPink },
                    ultravioletOrange: { value: this.neonColors.ultravioletOrange },
                    toxicGreen: { value: this.neonColors.toxicGreen }
                },
                vertexShader: `
                    uniform float time;
                    uniform float amplitude;
                    uniform float subBass;
                    uniform float bass;
                    uniform float lowMid;
                    uniform float mid;
                    uniform float highMid;
                    uniform float presence;
                    uniform float brilliance;
                    uniform float reactivity;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying float vDisplacement;
                    varying float vFresnelFactor;
                    varying float vSpeechActivity;
                    
                    // Simplex noise function
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ * ns.x + ns.yyyy;
                        vec4 y = y_ * ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0) * 2.0 + 1.0;
                        vec4 s1 = floor(b1) * 2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
                        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
                    }
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        
                        vec3 pos = position;
                        float timeSpeed = time * 1.2;
                        
                        // Speech-reactive displacement
                        float speechBase = snoise(pos * 1.8 + vec3(timeSpeed * 0.4, 0.0, 0.0)) * (bass + lowMid) * 0.25 * reactivity;
                        float vowelFormation = snoise(pos * 3.5 + vec3(0.0, timeSpeed * 0.8, timeSpeed * 0.6)) * mid * 0.2 * reactivity;
                        float consonantDetail = snoise(pos * 8.0 + vec3(timeSpeed * 1.5, 0.0, timeSpeed * 1.2)) * (highMid + presence) * 0.15 * reactivity;
                        float breathDetail = snoise(pos * 15.0 + vec3(timeSpeed * 2.0, timeSpeed * 1.8, 0.0)) * brilliance * 0.1 * reactivity;
                        
                        float speechIntensity = (bass + lowMid + mid + highMid + presence) * 0.2;
                        vSpeechActivity = speechIntensity;
                        
                        float globalPulse = 1.0 + amplitude * 0.3 * reactivity;
                        float totalDisplacement = speechBase + vowelFormation + consonantDetail + breathDetail;
                        vDisplacement = totalDisplacement;
                        
                        vec3 displaced = pos + normal * totalDisplacement;
                        displaced *= globalPulse;
                        
                        vWorldPosition = (modelMatrix * vec4(displaced, 1.0)).xyz;
                        
                        vec4 worldPosition = modelMatrix * vec4(displaced, 1.0);
                        vec3 worldNormal = normalize(normalMatrix * normal);
                        vec3 viewDirection = normalize(cameraPosition - worldPosition.xyz);
                        vFresnelFactor = pow(1.0 - abs(dot(viewDirection, worldNormal)), 2.0);
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float amplitude;
                    uniform float mid;
                    uniform float highMid;
                    uniform float presence;
                    uniform vec3 electricBlue;
                    uniform vec3 scorchedPink;
                    uniform vec3 ultravioletOrange;
                    uniform vec3 toxicGreen;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying float vDisplacement;
                    varying float vFresnelFactor;
                    varying float vSpeechActivity;
                    
                    void main() {
                        float colorCycle = sin(time * 0.8) * 0.5 + 0.5;
                        
                        vec3 glassBase = mix(electricBlue, scorchedPink, colorCycle);
                        vec3 midColor = mix(glassBase, ultravioletOrange, mid * 0.7);
                        vec3 finalColor = mix(midColor, toxicGreen, (highMid + presence) * 0.5);
                        
                        float internalEnergy = abs(vDisplacement) * 3.0 + vSpeechActivity;
                        float speechPattern = sin(vPosition.x * 20.0 + time * 4.0) * 
                                            cos(vPosition.y * 15.0 + time * 3.0) * 
                                            sin(vPosition.z * 25.0 + time * 5.0) * 
                                            vSpeechActivity * 0.4;
                        
                        float rimIntensity = vFresnelFactor * 2.5;
                        vec3 result = finalColor * (0.6 + internalEnergy + rimIntensity + abs(speechPattern));
                        
                        float alpha = 0.25 + rimIntensity * 0.5 + vSpeechActivity * 0.3;
                        alpha += abs(speechPattern) * 0.2;
                        alpha = clamp(alpha, 0.2, 0.9);
                        
                        gl_FragColor = vec4(result, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            
            this.narratorOrb = new THREE.Mesh(geometry, material);
            this.scene.add(this.narratorOrb);
        }
        
        createReflectionSystem() {
            // Reflection plane
            const planeGeometry = new THREE.PlaneGeometry(15, 15);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.1
            });
            
            this.reflectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            this.reflectionPlane.rotation.x = -Math.PI / 2;
            this.reflectionPlane.position.y = -2.5;
            this.scene.add(this.reflectionPlane);
            
            // Reflected orb
            this.reflectedOrb = this.narratorOrb.clone();
            this.reflectedOrb.scale.y = -1;
            this.reflectedOrb.position.y = -5;
            this.reflectedOrb.material = this.reflectedOrb.material.clone();
            
            // Modify reflection shader
            this.reflectedOrb.material.fragmentShader = this.reflectedOrb.material.fragmentShader.replace(
                'gl_FragColor = vec4(result, alpha);',
                `
                float distanceFromCenter = length(vWorldPosition.xz) / 8.0;
                float reflectionFade = 1.0 - clamp(distanceFromCenter, 0.0, 1.0);
                alpha *= 0.4 * reflectionFade;
                gl_FragColor = vec4(result * 0.7, alpha);
                `
            );
            
            this.reflectedOrb.material.needsUpdate = true;
            this.scene.add(this.reflectedOrb);
        }
        
        setupEventListeners() {
            // File input
            const fileInput = document.getElementById('audioFile');
            if (fileInput) {
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) this.loadAudioFile(file);
                });
            }
            
            // Control buttons
            const playBtn = document.getElementById('playBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const exportBtn = document.getElementById('exportBtn');
            
            if (playBtn) playBtn.addEventListener('click', () => this.playAudio());
            if (pauseBtn) pauseBtn.addEventListener('click', () => this.pauseAudio());
            if (exportBtn) exportBtn.addEventListener('click', () => this.exportVideo());
            
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') { 
                    e.preventDefault(); 
                    this.togglePlayPause(); 
                }
                if (e.code === 'KeyE') { 
                    e.preventDefault(); 
                    this.exportVideo(); 
                }
            });
            
            // Drag & drop
            const container = document.getElementById('container');
            const dropZone = document.getElementById('dropZone');
            
            if (container && dropZone) {
                container.addEventListener('dragover', (e) => { 
                    e.preventDefault(); 
                    dropZone.classList.add('active');
                });
                
                container.addEventListener('dragleave', (e) => {
                    if (!container.contains(e.relatedTarget)) {
                        dropZone.classList.remove('active');
                    }
                });
                
                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('active');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) this.loadAudioFile(files[0]);
                });
            }
            
            // Window resize
            window.addEventListener('resize', () => this.onWindowResize());
        }
        
        async loadAudioFile(file) {
            this.showLoading(true);
            
            try {
                console.log('Loading audiobook:', file.name);
                
                // File validation
                if (!file.type.startsWith('audio/') && !file.type.startsWith('video/')) {
                    throw new Error('Please select a valid audio or video file');
                }
                
                this.audioElement = new Audio();
                this.audioElement.crossOrigin = 'anonymous';
                
                const url = URL.createObjectURL(file);
                this.audioElement.src = url;
                
                await new Promise((resolve, reject) => {
                    this.audioElement.addEventListener('loadeddata', resolve);
                    this.audioElement.addEventListener('error', reject);
                    this.audioElement.load();
                });
                
                // Audio context setup
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                if (this.source) this.source.disconnect();
                
                this.source = this.audioContext.createMediaElementSource(this.audioElement);
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 8192;
                this.analyser.smoothingTimeConstant = 0.7;
                
                this.source.connect(this.analyser);
                this.analyser.connect(this.audioContext.destination);
                
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                
                // Update UI
                const titleEl = document.getElementById('audioTitle');
                const infoEl = document.getElementById('audioInfo');
                const playBtn = document.getElementById('playBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const exportBtn = document.getElementById('exportBtn');
                
                if (titleEl) titleEl.textContent = file.name;
                if (infoEl) infoEl.style.display = 'block';
                if (playBtn) playBtn.disabled = false;
                if (pauseBtn) pauseBtn.disabled = false;
                if (exportBtn) exportBtn.disabled = false;
                
                this.showSuccess(`‚úÖ "${file.name}" loaded successfully!`);
                
                // Cleanup
                URL.revokeObjectURL(url);
                
            } catch (error) {
                console.error('Error loading file:', error);
                this.showError(`Failed to load file: ${error.message}`);
            } finally {
                this.showLoading(false);
            }
        }
        
        async playAudio() {
            if (!this.audioElement) return;
            
            try {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                await this.audioElement.play();
                this.isPlaying = true;
                this.showSuccess('üéµ Playing...');
            } catch (error) {
                console.error('Play error:', error);
                this.showError('Failed to play audio');
            }
        }
        
        pauseAudio() {
            if (this.audioElement) {
                this.audioElement.pause();
                this.isPlaying = false;
                this.showSuccess('‚è∏ Paused');
            }
        }
        
        togglePlayPause() {
            if (this.isPlaying) {
                this.pauseAudio();
            } else {
                this.playAudio();
            }
        }
        
        async exportVideo() {
            if (!this.audioElement) {
                this.showError('Please load an audiobook file first');
                return;
            }
            
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.disabled = true;
                exportBtn.textContent = 'üé¨ Recording...';
            }
            
            try {
                this.audioElement.currentTime = 0;
                const duration = this.audioElement.duration;
                
                // MediaRecorder setup
                let mimeType = 'video/webm';
                if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus')) {
                    mimeType = 'video/webm;codecs=vp9,opus';
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) {
                    mimeType = 'video/webm;codecs=vp8,opus';
                }
                
                const canvasStream = this.renderer.domElement.captureStream(60);
                const audioDestination = this.audioContext.createMediaStreamDestination();
                this.source.connect(audioDestination);
                
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...audioDestination.stream.getAudioTracks()
                ]);
                
                this.mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 8000000,
                    audioBitsPerSecond: 320000
                });
                
                this.recordedChunks = [];
                this.mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) this.recordedChunks.push(e.data);
                };
                
                this.mediaRecorder.onstop = () => this.downloadVideo();
                
                this.mediaRecorder.start(100);
                await this.playAudio();
                
                this.showSuccess(`üé¨ Recording ${duration.toFixed(1)}s...`);
                
                setTimeout(() => {
                    if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                        this.mediaRecorder.stop();
                    }
                    if (exportBtn) {
                        exportBtn.disabled = false;
                        exportBtn.textContent = 'üé¨ Export Video';
                    }
                }, (duration + 1) * 1000);
                
            } catch (error) {
                console.error('Export error:', error);
                this.showError(`Export failed: ${error.message}`);
                if (exportBtn) {
                    exportBtn.disabled = false;
                    exportBtn.textContent = 'üé¨ Export Video';
                }
            }
        }
        
        downloadVideo() {
            try {
                const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
                
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `audiobook-narrator-orb-${timestamp}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                this.showSuccess('‚úÖ Video exported successfully!');
            } catch (error) {
                console.error('Download error:', error);
                this.showError('Failed to download video');
            }
        }
        
        updateAudioAnalysis() {
            if (!this.analyser || !this.isPlaying || !this.dataArray) return;
            
            try {
                this.analyser.getByteFrequencyData(this.dataArray);
                
                let sum = 0;
                for (let i = 0; i < this.dataArray.length; i++) {
                    sum += this.dataArray[i];
                }
                const rawAmplitude = sum / this.dataArray.length / 255;
                
                this.amplitude += (rawAmplitude - this.amplitude) * this.speechReactivity.responsiveness;
                this.smoothedAmplitude += (this.amplitude - this.smoothedAmplitude) * this.speechReactivity.smoothing;
                
                // Frequency analysis
                const nyquist = this.audioContext.sampleRate / 2;
                const binSize = nyquist / this.dataArray.length;
                
                const bands = {
                    subBass: [20, 60],
                    bass: [60, 250],
                    lowMid: [250, 500],
                    mid: [500, 2000],
                    highMid: [2000, 4000],
                    presence: [4000, 6000],
                    brilliance: [6000, 20000]
                };
                
                Object.keys(bands).forEach(band => {
                    const [minFreq, maxFreq] = bands[band];
                    const startBin = Math.floor(minFreq / binSize);
                    const endBin = Math.min(Math.floor(maxFreq / binSize), this.dataArray.length - 1);
                    
                    let sum = 0;
                    let count = 0;
                    for (let i = startBin; i <= endBin; i++) {
                        sum += this.dataArray[i];
                        count++;
                    }
                    
                    const rawValue = count > 0 ? sum / count / 255 : 0;
                    const responsiveness = band === 'mid' || band === 'highMid' ? 0.3 : 0.2;
                    this.voiceFrequencies[band] += (rawValue - this.voiceFrequencies[band]) * responsiveness;
                });
            } catch (error) {
                // Silently handle audio analysis errors
            }
        }
        
        updateVisuals() {
            if (!this.isInitialized) return;
            
            const time = this.clock.getElapsedTime();
            
            // Update orb shader uniforms
            if (this.narratorOrb && this.narratorOrb.material.uniforms) {
                const uniforms = this.narratorOrb.material.uniforms;
                uniforms.time.value = time;
                uniforms.amplitude.value = this.smoothedAmplitude;
                uniforms.subBass.value = this.voiceFrequencies.subBass;
                uniforms.bass.value = this.voiceFrequencies.bass;
                uniforms.lowMid.value = this.voiceFrequencies.lowMid;
                uniforms.mid.value = this.voiceFrequencies.mid;
                uniforms.highMid.value = this.voiceFrequencies.highMid;
                uniforms.presence.value = this.voiceFrequencies.presence;
                uniforms.brilliance.value = this.voiceFrequencies.brilliance;
            }
            
            // Update reflection
            if (this.reflectedOrb && this.reflectedOrb.material.uniforms) {
                Object.assign(this.reflectedOrb.material.uniforms, this.narratorOrb.material.uniforms);
            }
            
            // Dynamic lighting
            const speechActivity = (this.voiceFrequencies.mid + this.voiceFrequencies.highMid + this.voiceFrequencies.presence) / 3;
            
            if (this.lights.keyLight) {
                this.lights.keyLight.intensity = 2 + speechActivity * 1.5;
            }
            if (this.lights.fillLight) {
                this.lights.fillLight.intensity = 1.5 + this.voiceFrequencies.bass * 0.8;
            }
            if (this.lights.rimLight) {
                this.lights.rimLight.intensity = 1 + this.voiceFrequencies.brilliance * 1.2;
            }
            
            // Rotation
            const rotationSpeed = 0.003 * (1 + speechActivity * 0.7);
            
            if (this.narratorOrb) {
                this.narratorOrb.rotation.y += rotationSpeed;
                this.narratorOrb.rotation.x += rotationSpeed * 0.4;
            }
            
            if (this.reflectedOrb) {
                this.reflectedOrb.rotation.y += rotationSpeed;
                this.reflectedOrb.rotation.x += rotationSpeed * 0.4;
            }
            
            // Starfield
            if (this.starField) {
                this.starField.rotation.y += 0.0002;
                this.starField.material.opacity = 0.6 + speechActivity * 0.2;
            }
        }
        
        updateCamera() {
            if (!this.isInitialized) return;
            
            const time = this.clock.getElapsedTime();
            const speechIntensity = (this.voiceFrequencies.mid + this.voiceFrequencies.presence) / 2;
            const radius = 8 + Math.sin(time * 0.08) * 1.5 + speechIntensity * 0.5;
            const speed = 0.02 + speechIntensity * 0.01;
            
            this.camera.position.x = Math.sin(time * speed) * radius;
            this.camera.position.z = Math.cos(time * speed) * radius;
            this.camera.position.y = 1 + Math.sin(time * 0.03) * 0.8 + speechIntensity * 0.3;
            
            this.camera.lookAt(0, 0, 0);
        }
        
        updateTimeDisplay() {
            if (!this.audioElement) return;
            
            const current = this.audioElement.currentTime || 0;
            const duration = this.audioElement.duration || 0;
            
            const formatTime = (time) => {
                const mins = Math.floor(time / 60);
                const secs = Math.floor(time % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            };
            
            const timeDisplay = document.getElementById('audioTime');
            if (timeDisplay) {
                timeDisplay.textContent = `${formatTime(current)} / ${formatTime(duration)}`;
            }
        }
        
        showLoading(show) {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.display = show ? 'block' : 'none';
            }
        }
        
        onWindowResize() {
            if (!this.camera || !this.renderer) return;
            
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        animate() {
            if (!this.isInitialized) return;
            
            requestAnimationFrame(() => this.animate());
            
            try {
                this.updateAudioAnalysis();
                this.updateVisuals();
                this.updateCamera();
                this.updateTimeDisplay();
                
                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            } catch (error) {
                console.error('Animation error:', error);
            }
        }
    };
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        try {
            new window.AudiobookNarratorOrb();
        } catch (error) {
            console.error('Failed to initialize:', error);
            const errorEl = document.getElementById('errorMessage');
            if (errorEl) {
                errorEl.style.display = 'block';
                errorEl.textContent = 'Initialization failed. Please refresh the page.';
            }
        }
    });
    
})();
```
